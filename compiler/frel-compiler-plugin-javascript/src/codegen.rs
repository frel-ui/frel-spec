// JavaScript code generation
//
// This module implements the actual code generation logic.

use frel_compiler_core::ast::*;

/// Generate JavaScript code for a Frel file
pub fn generate_file(file: &File) -> String {
    let mut output = String::new();

    // File header
    output.push_str(&format!(
        "// Generated by Frel compiler\n\
         // Module: {}\n\
         // DO NOT EDIT - This file is auto-generated\n\n",
        file.module.segments.join(".")
    ));

    // Runtime import
    output.push_str("import { Runtime, Fragment } from '@frel/runtime';\n\n");

    // Generate imports
    for import in &file.imports {
        output.push_str(&generate_import(import));
    }

    if !file.imports.is_empty() {
        output.push('\n');
    }

    // Generate declarations
    for decl in &file.declarations {
        output.push_str(&generate_declaration(decl));
        output.push('\n');
    }

    output
}

fn generate_import(import: &Import) -> String {
    format!(
        "import {{ {} }} from '@frel/{}';\n",
        import.name,
        import.module.segments.join("/")
    )
}

fn generate_declaration(decl: &TopLevelDecl) -> String {
    match decl {
        TopLevelDecl::Blueprint(blueprint) => generate_blueprint(blueprint),
        TopLevelDecl::Backend(backend) => generate_backend(backend),
        TopLevelDecl::Contract(contract) => generate_contract(contract),
        TopLevelDecl::Scheme(scheme) => generate_scheme(scheme),
        TopLevelDecl::Enum(enum_decl) => generate_enum(enum_decl),
        TopLevelDecl::Theme(theme) => generate_theme(theme),
        TopLevelDecl::Arena(arena) => generate_arena(arena),
    }
}

fn generate_blueprint(blueprint: &Blueprint) -> String {
    let mut output = String::new();

    output.push_str(&format!("export class {} extends Fragment {{\n", blueprint.name));

    // Constructor
    output.push_str("  constructor(runtime, parent, params) {\n");
    output.push_str("    super(runtime, parent);\n");
    output.push_str("    // TODO: Initialize blueprint\n");
    output.push_str("  }\n\n");

    // Build method
    output.push_str("  build() {\n");
    output.push_str("    // TODO: Build fragment tree\n");
    output.push_str("  }\n");

    output.push_str("}\n");

    output
}

fn generate_backend(backend: &Backend) -> String {
    let mut output = String::new();

    output.push_str(&format!("export class {} {{\n", backend.name));

    // Constructor
    output.push_str("  constructor() {\n");
    output.push_str("    // TODO: Initialize backend fields\n");
    output.push_str("  }\n\n");

    // Generate methods and commands
    for member in &backend.members {
        match member {
            BackendMember::Method(method) => {
                output.push_str(&format!("  {}() {{\n", method.name));
                output.push_str("    // TODO: Implement method\n");
                output.push_str("  }\n\n");
            }
            BackendMember::Command(command) => {
                output.push_str(&format!("  async {}() {{\n", command.name));
                output.push_str("    // TODO: Implement command\n");
                output.push_str("  }\n\n");
            }
            _ => {}
        }
    }

    output.push_str("}\n");

    output
}

fn generate_contract(_contract: &Contract) -> String {
    // Contracts are runtime-bound, so we just export a marker
    String::from("// Contract placeholder\n")
}

fn generate_scheme(scheme: &Scheme) -> String {
    let mut output = String::new();

    output.push_str(&format!("export class {} {{\n", scheme.name));
    output.push_str("  constructor(data) {\n");
    output.push_str("    Object.assign(this, data);\n");
    output.push_str("  }\n");
    output.push_str("}\n");

    output
}

fn generate_enum(enum_decl: &Enum) -> String {
    let mut output = String::new();

    output.push_str(&format!("export const {} = {{\n", enum_decl.name));

    for (i, variant) in enum_decl.variants.iter().enumerate() {
        output.push_str(&format!("  {}: {},\n", variant, i));
    }

    output.push_str("};\n");

    output
}

fn generate_theme(theme: &Theme) -> String {
    let mut output = String::new();

    output.push_str(&format!("export class {} {{\n", theme.name));
    output.push_str("  constructor() {\n");
    output.push_str("    // TODO: Initialize theme fields\n");
    output.push_str("  }\n");
    output.push_str("}\n");

    output
}

fn generate_arena(arena: &Arena) -> String {
    format!(
        "export const {} = new Arena('{}');\n",
        arena.name, arena.scheme_name
    )
}
