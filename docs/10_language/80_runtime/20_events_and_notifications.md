# Events and Notifications

## Events

Frel runtime is event-driven. All events are put into the event queue. The event queue
provides two functions: `put_event` and `drain_events`.

The `put_event` function is thread-safe, can be called at any time by any thread.

The `drain_events` function is **NOT** thread safe, and it may be called only from
the main UI thread. Actual implementations bind the two functions together, it is
not in the scope of the language to define when to call `drain_events`.

Events may come from different sources:

- user actions (mouse, keyboard, gestures etc.)
- network traffic
- timers

## Notifications

Notifications are generated by events. When an event changes a datum, a new notification
is created for each subscription. 

All notifications are put into the notification queue. The notification queue provides two
functions: `put_notification` and `drain_notifications`.

Both functions are **NOT** thread safe, they are called from `drain_events` so they run
in the main thread.

- In actual implementations the notifications are simply subscription keys.
- Notification processing **DO NOT** preserve the order of subscriptions.
- Notifications are processed in batches called *generations*.
- `drain_notifications` works in a loop where each cycle performs the following steps.
    1. Sanity check, the loop should finish in less than or equal `GEN_LIMIT` cycles (1000 by default).
    2. Take all pending notifications from the queue: the **processed generation**.
    3. Empty the queue and increase the generation counter,
    4. Call callback functions of the **processed generation**.
        1. May change datum, those changes belong to the **next generation**.
        2. May queue a re-render (which is processed outside the data subsystem).
    5. Stop the cycle if the **next generation** has no notifications.

This ensures that all pending work is finished and all cascading changes are applied to
the appropriate data.

**Note**

When a field changes, the datum implementation saves the current generation of the 
runtime into `set_generation` of the datum structure.

### Subscribe during drain

Subscription during drain (which is almost all subscriptions in practice) has the
following behavior.

If `set_generation` of the subscribed datum is the current generation of the runtime, the
runtime queues a notification for the subscription. This ensures that the subscriber
will be notified of changes as well.

If `set_generation` is not the current generation of the runtime, the notification is **NOT**
added to the pending queue. If some callbacks change the datum later during the drain,
the notification will be automatically added to the queue by the normal mechanism.

### Unsubscribe during drain

Unsubscribe during drain (also almost all cases in practice) simply removes the subscription
from the subscriptions managed by the runtime.

If the subscription key is reached later during the drain, the function won't be able to
fetch the subscription as it has been already removed. In this case it simply skips
the key and goes on.